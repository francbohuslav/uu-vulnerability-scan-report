import core from "./core";
import { DependenciesParser } from "./dependenciesParser";
import { ICommandOptions, IConsole, INode, IParser, IVulnerability } from "./interfaces";

export class OwaspParser implements IParser {
  constructor(private console: IConsole) {}

  public parse(options: ICommandOptions): INode[] {
    const treeList = new DependenciesParser(this.console).parse(options.dependencies ?? "");
    const report = JSON.parse(core.readTextFile(options.sourceReport)) as IDCR$Root;
    for (const dependency of report.dependencies) {
      if (dependency.vulnerabilities && dependency.vulnerabilities.length > 0) {
        const vulnerabilitiesPerLibrary = this.createVulnerabilities(dependency);
        this.setVulnerabilityToNodes(treeList, vulnerabilitiesPerLibrary);
        // Can't be used because checkStyle configuration is ommited
        // this.checkAllVulnerabilitiesUsage(vulnerabilitiesPerLibrary);
      }
    }
    // core.writeTextFile("../test.json", JSON.stringify(treeList, null, 2));
    return treeList;
  }

  private createVulnerabilities(dependency: IDCR$Dependency): Map<string, IPackageVulnerabilities> {
    const vulPerPackage = new Map<string, IPackageVulnerabilities>();
    for (const dcrPackage of dependency.packages) {
      const vulnerabilities: IVulnerability[] = [];
      for (const dcrVulnerability of dependency.vulnerabilities) {
        const vulnerability: IVulnerability = {
          importance: dcrVulnerability.severity,
          title: dcrVulnerability.description?.trim(),
          url: dcrPackage.url,
          cve: dcrVulnerability.name,
          cwe: dcrVulnerability.cwes.join(", "),
        };
        vulnerabilities.push(vulnerability);
      }
      const match = dcrPackage.id.match(/^pkg:maven\/([^/]+)\/([^/]+@.+)$/);
      if (match) {
        vulPerPackage.set(`${match[1]}:${match[2]}`, { vulnerabilities, used: 0 });
      } else {
        this.console.error(`Package id '${dcrPackage.id}' does not match pattern pkg:maven/com.rabbitmq/amqp-client@5.13.1"`);
      }
    }
    return vulPerPackage;
  }

  private setVulnerabilityToNodes(treeList: INode[], vulnerabilitiesPerLibrary: Map<string, IPackageVulnerabilities>) {
    for (const tree of treeList) {
      const vuls = vulnerabilitiesPerLibrary.get(tree.library + "@" + tree.version);
      if (vuls) {
        tree.vulnerabilities = vuls.vulnerabilities;
        vuls.used++;
      }
      if (tree.childNodes.length > 0) {
        this.setVulnerabilityToNodes(tree.childNodes, vulnerabilitiesPerLibrary);
      }
    }
  }

  private checkAllVulnerabilitiesUsage(vulnerabilitiesPerLibrary: Map<string, IPackageVulnerabilities>) {
    for (const [pack, vul] of vulnerabilitiesPerLibrary.entries()) {
      if (vul.used === 0) {
        this.console.error(`Vulnerable package '${pack}' not found in dependency tree. This should never happen.`);
      }
    }
  }
}

interface IDCR$Root {
  dependencies: IDCR$Dependency[];
}

interface IDCR$Dependency {
  /** "The RabbitMQ Java client library allows Java applications to interface with RabbitMQ." */
  description: string;
  vulnerabilities: IDCR$Vulnerability[];
  packages: IDCR$Package[];
}

interface IDCR$Vulnerability {
  /** "CVE-2023-46120" */
  name: string;

  /** "NVD" */
  source: string;

  /** "HIGH" */
  severity: string;

  /** [ "CWE-400" ] */
  cwes: string[];
  description: string;
}

interface IDCR$Package {
  /** "pkg:maven/com.rabbitmq/amqp-client@5.13.1" */
  id: string;
  /** "HIGH",... */
  confidence: string;
  url: string;
}

interface IPackageVulnerabilities {
  used: number;
  vulnerabilities: IVulnerability[];
}
