import core from "./core";
import { Filter } from "./filter";
import { ICommandOptions, IConsole, IParser, IVulnerableOccurrence } from "./interfaces";
import { OwaspParser } from "./owaspParser";
import { SonatypeParser } from "./sonatypeParser";
import { TrivyParser } from "./trivyParser";
import { UuDirectReport } from "./uuDirectReport";
import { UuStringReport } from "./uuStringReport";
import { VulnerabilityCollector } from "./vulnerabilityCollector";

export class VulnerabilityScan {
  constructor(private options: ICommandOptions, private console: IConsole) {}

  public run() {
    if (this.options.include.length > 0) {
      this.console.log("Only these libraries will be included");
      for (const pattern of this.options.include) {
        this.console.log(" - " + pattern);
      }
    }
    if (this.options.exclude.length > 0) {
      this.console.log("These libraries will be excluded");
      for (const pattern of this.options.exclude) {
        this.console.log(" - " + pattern);
      }
    }
    const parser = this.detectParser();
    const topNodes = parser.parse(this.options);

    // Must be before filter
    const directFile = this.options.output + "-direct-dependencies.txt";
    if (this.options.output) {
      core.writeTextFile(directFile, new UuDirectReport().getUuString(topNodes, this.options.projectName, this.options.projectInternal));
    }

    const filter = new Filter();
    const filteredNodes = filter.filter(
      topNodes,
      this.options.include.map((i) => new RegExp(i)),
      this.options.exclude.map((i) => new RegExp(i))
    );

    const collector = new VulnerabilityCollector();
    const vulnerabilities = collector.collect(filteredNodes);
    const report = JSON.stringify(vulnerabilities, null, 2);

    if (this.options.teamcity) {
      Object.values(vulnerabilities).forEach((v) => this.reportToTeamcity(v));
    }

    if (this.options.output) {
      const vulFile = this.options.output + "-vulnerabilities.json";
      core.writeTextFile(vulFile, report);
      this.console.log(`Vulnerability tree exported to ${vulFile}`);

      const uuFile = this.options.output + "-uu.txt";
      core.writeTextFile(uuFile, new UuStringReport().getUuString(vulnerabilities));
      this.console.log(`Vulnerabilities for UU exported to ${uuFile}`);
      this.console.log(`Direct dependencies exported to ${directFile}`);
    }
  }

  private detectParser(): IParser {
    const content = core.readTextFile(this.options.sourceReport);
    if (content.includes("SchemaVersion") && content.includes("ArtifactType")) {
      return new TrivyParser(console);
    } else if (content.includes(":ossIndexAudit")) {
      return new SonatypeParser(console);
    }
    return new OwaspParser(console);
  }

  private reportToTeamcity(occ: IVulnerableOccurrence) {
    const vul = occ.vulnerability;
    const stepTcName = this.teamCityEscape(occ.key) + ": " + this.teamCityEscape(vul.title);
    this.console.log(`##teamcity[testStarted name='${stepTcName}']`);
    this.console.log(`##teamcity[testFailed name='${stepTcName}' message='${this.teamCityEscape(vul.title)}']`);
    if (vul.cve) {
      this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cve' value='${this.teamCityEscape(vul.cve)}']`);
    }
    if (vul.cwe) {
      this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cwe' value='${this.teamCityEscape(vul.cwe)}']`);
    }
    this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='importance' value='${this.teamCityEscape(vul.importance)}']`);
    this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='url' type='link' value='${this.teamCityEscape(vul.url)}']`);

    if (occ.usedBy.length) {
      occ.usedBy.forEach((libraries, i) =>
        this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='usedBy-${i}' value='${this.teamCityEscape(libraries.join(", "))}']`)
      );
    }
    this.console.log(`##teamcity[testFinished name='${stepTcName}']`);
  }

  private teamCityEscape(text: string): string {
    return text.replace(/\|/g, "||").replace(/'/g, "|'").replace(/\r/g, "|r").replace(/\n/g, "|n").replace(/\]/g, "|]").replace(/\[/g, "|[");
  }
}
