import core from "./core";
import path from "path";

export class VulnerabilityScan {
    private whitelist: string[] = [
        "pkg:maven/uu.appg01/uu_appg01_oidc-client@",
        "pkg:maven/uu.appg01/uu_appg01_messagebroker@",
        "pkg:maven/uu.appg01/uu_appg01_server@",
    ];

    constructor(private options: ICommandOptions) {}

    public async run() {
        const content = core.readTextFile(this.options.sourceReport);
        const json = JSON.parse(content);
        const compact = this.getVulnerabilities(json);
        const parsed = path.parse(this.options.sourceReport);
        const destFile = parsed.dir + path.sep + parsed.name + "_tree.json";
        const report = JSON.stringify(compact, null, 2);
        if (this.options.outputFile) {
            core.writeTextFile(destFile, report);
            console.log("Vulnerability tree exported to " + destFile);
        } else {
            if (this.options.teamcity) {
                compact.forEach((c) => this.reportToTeamcity(c));
            } else {
                console.log(report);
            }
        }
    }
    private reportToTeamcity(vul: IVulnerability) {
        const stepTcName = this.teamCityEscape(vul.displayName);
        console.log(`##teamcity[testStarted name='${stepTcName}']`);
        console.log(`##teamcity[testFailed name='${stepTcName}' message='${this.teamCityEscape(vul.title)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cvssScore' type='number' value='${vul.cvssScore}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cve' value='${this.teamCityEscape(vul.cve)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='id' value='${this.teamCityEscape(vul.id)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='description' value='${this.teamCityEscape(vul.description)}']`);
        if (vul.reference) {
            console.log(`##teamcity[testMetadata testName='${stepTcName}' name='reference' type='link' value='${this.teamCityEscape(vul.reference)}']`);
        }
        if (vul.externalReferences && vul.externalReferences) {
            vul.externalReferences.forEach((r, i) =>
                console.log(`##teamcity[testMetadata testName='${stepTcName}' name='externalReferences-${i}' type='link' value='${this.teamCityEscape(r)}']`)
            );
        }
        console.log(`##teamcity[testFinished name='${stepTcName}']`);
    }

    private teamCityEscape(text: string): string {
        return text.replace(/\|/g, "||").replace(/'/g, "|'").replace(/\r/g, "|r").replace(/\n/g, "|n").replace(/\]/g, "|]").replace(/\[/g, "|[");
    }

    private getVulnerabilities(json: INodeList) {
        const vulnearbilites: { [id: string]: IVulnerability } = {};
        Object.entries(json)
            .filter(([_name, n]) => n.vulnerabilities && n.vulnerabilities.length > 1)
            .forEach(([name, n]) =>
                n.vulnerabilities.forEach((v) => {
                    vulnearbilites[v.id] = v;
                    vulnearbilites[v.id].usedBy = vulnearbilites[v.id].usedBy || new Set<string>();
                    const news = this.addSelfAndParents(new Set<string>(), name, json);
                    if (news && news.size) {
                        news.forEach((n) => vulnearbilites[v.id].usedBy.add(n));
                    }
                })
            );
        const vulArray = Object.values(vulnearbilites).filter((v) => v.usedBy.size);
        vulArray.forEach((v) => {
            v.usedBy = [...v.usedBy] as any;
        });
        return vulArray;
    }

    private addSelfAndParents(nodes: Set<string>, name: string, json: INodeList): Set<string> {
        if (!name || name == "ROOT") {
            return nodes;
        }
        for (const pattern of this.whitelist) {
            if (name.indexOf(pattern) > -1) {
                return null;
            }
        }
        nodes.add(name);
        const parent = json[name];
        if (parent) {
            return this.addSelfAndParents(nodes, parent.from, json);
        }
    }
}

type INodeList = { [pack: string]: INode };

interface INode {
    from: string;
    vulnerabilities: IVulnerability[];
}

interface IVulnerability {
    id: string;
    displayName: string;
    title: string;
    description: string;
    cve: string;
    cvssScore: string;
    reference: string;
    externalReferences: string[];
    usedBy: Set<string>;
}

export interface ICommandOptions {
    sourceReport: string;
    outputFile: string;
    teamcity: boolean;
}
