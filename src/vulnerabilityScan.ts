import core from "./core";
const jsonPath = require("JSONPath");

export class VulnerabilityScan {
    private whitelist: string[] = [
        "pkg:maven/uu.appg01/uu_appg01_oidc-client@",
        "pkg:maven/uu.appg01/uu_appg01_messagebroker@",
        "pkg:maven/uu.appg01/uu_appg01_server@",
    ];

    constructor(private options: ICommandOptions) { }
    private getDependencyCheckValues() {
        const DependencyCheckJson = core.readTextFile(this.options.dependencyCheck);
        const DependencyCheckObject = JSON.parse(DependencyCheckJson);
        const parsedDependencyCheckObject = jsonPath({ json: DependencyCheckObject, path: "$..dependencies..packages" })
        return [...new Set([].concat(...parsedDependencyCheckObject.map((o: any) => o)))].map((o) => o.id);
    }
    public async run() {
        const content = core.readTextFile(this.options.sourceReport);
        const dependencyCheckValues = this.getDependencyCheckValues();
        const json = JSON.parse(content);
        const compact = this.getVulnerabilities(json, dependencyCheckValues);
        const report = JSON.stringify(compact, null, 2);
        if (this.options.outputFile) {
            core.writeTextFile(this.options.outputFile, report);
            console.log("Vulnerability tree exported to " + this.options.outputFile);
        }

        if (this.options.teamcity) {
            compact.forEach((c) => this.reportToTeamcity(c));
        } else {
            console.log(report);
        }
    }
    private reportToTeamcity(vul: IVulnerability) {
        const stepTcName = this.teamCityEscape(vul.displayName);
        console.log(`##teamcity[testStarted name='${stepTcName}']`);
        console.log(`##teamcity[testFailed name='${stepTcName}' message='${this.teamCityEscape(vul.description)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='_title' value='${this.teamCityEscape(vul.title)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cvssScore' type='number' value='${vul.cvssScore}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cve' value='${this.teamCityEscape(vul.cve)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='id' value='${this.teamCityEscape(vul.id)}']`);
        if (vul.reference) {
            console.log(`##teamcity[testMetadata testName='${stepTcName}' name='reference' type='link' value='${this.teamCityEscape(vul.reference)}']`);
        }
        if (vul.externalReferences && vul.externalReferences) {
            vul.externalReferences.forEach((r, i) =>
                console.log(`##teamcity[testMetadata testName='${stepTcName}' name='externalReferences-${i}' type='link' value='${this.teamCityEscape(r)}']`)
            );
        }
        if (vul.usedBy && vul.usedBy) {
            vul.usedBy.forEach((r, i) => console.log(`##teamcity[testMetadata testName='${stepTcName}' name='usedBy-${i}' value='${this.teamCityEscape(r)}']`));
        }
        console.log(`##teamcity[testFinished name='${stepTcName}']`);
    }

    private teamCityEscape(text: string): string {
        return text.replace(/\|/g, "||").replace(/'/g, "|'").replace(/\r/g, "|r").replace(/\n/g, "|n").replace(/\]/g, "|]").replace(/\[/g, "|[");
    }

    private getVulnerabilities(json: INodeList, dependencyCheckList: any[]) {
        const vulnearbilities: { [id: string]: IVulnerability } = {};
        let counter = 0;
        Object.entries(json)
            .filter(([_name, n]) => n.vulnerabilities && n.vulnerabilities.length > 1 || dependencyCheckList.includes(_name))
            .forEach(([name, n]) => {
                if (n.vulnerabilities === null) {
                    n.vulnerabilities = [{ id: "id" + counter, displayName: "displayName", title: "title", description: "description", cve: "cve", cvssScore: "cvssScore", reference: "reference", externalReferences: [], usedBy: [] }];
                    counter++;
                }
                n.vulnerabilities.forEach((v) => {
                    vulnearbilities[v.id] = v;
                    vulnearbilities[v.id].usedBy = vulnearbilities[v.id].usedBy || [];
                    const news = this.addSelfAndParents(new Set<string>(), name, json);
                    if (news && news.size) {
                        const asSet = new Set<string>(vulnearbilities[v.id].usedBy);
                        news.forEach((n) => asSet.add(n));
                        vulnearbilities[v.id].usedBy = [...asSet];
                    }
                })
            });
        const vulArray = Object.values(vulnearbilities).filter((v) => v.usedBy.length);
        vulArray.forEach((v) => {
            v.usedBy = [...v.usedBy] as any;
        });
        return vulArray;
    }

    private addSelfAndParents(nodes: Set<string>, name: string, json: INodeList): Set<string> {
        if (!name || name == "ROOT") {
            return nodes;
        }
        if (this.options.whitelist) {
            for (const pattern of this.whitelist) {
                if (name.indexOf(pattern) > -1) {
                    return null;
                }
            }
        }
        nodes.add(name);
        const parent = json[name];
        if (parent) {
            return this.addSelfAndParents(nodes, parent.from, json);
        }
    }
}

type INodeList = { [pack: string]: INode };

interface INode {
    from: string;
    vulnerabilities: IVulnerability[];
}

interface IVulnerability {
    id: string;
    displayName: string;
    title: string;
    description: string;
    cve: string;
    cvssScore: string;
    reference: string;
    externalReferences: string[];
    usedBy: string[];
}

export interface ICommandOptions {
    sourceReport: string;
    outputFile: string;
    dependencyCheck: string;
    teamcity: boolean;
    whitelist: boolean;
}
