import core from "./core";
import { Filter } from "./filter";
import { ICommandOptions, IConsole, IParser, IVulnerableOccurrence } from "./interfaces";
import { OwaspParser } from "./owaspParser";
import { SonatypeParser } from "./sonatypeParser";
import { UuStringReport } from "./uuStringReport";
import { VulnerabilityCollector } from "./vulnerabilityCollector";

export class VulnerabilityScan {
  constructor(private options: ICommandOptions, private console: IConsole) {}

  public run() {
    if (this.options.include.length > 0) {
      this.console.log("Only these libraries will be included");
      for (const pattern of this.options.include) {
        this.console.log(" - " + pattern);
      }
    }
    if (this.options.exclude.length > 0) {
      this.console.log("These libraries will be excluded");
      for (const pattern of this.options.exclude) {
        this.console.log(" - " + pattern);
      }
    }
    const parser = this.detectParser();
    const topNodes = parser.parse(this.options);

    const filter = new Filter();
    const filteredNodes = filter.filter(
      topNodes,
      this.options.include.map((i) => new RegExp(i)),
      this.options.exclude.map((i) => new RegExp(i))
    );

    const collector = new VulnerabilityCollector();
    const vulnerabilities = collector.collect(filteredNodes);
    const report = JSON.stringify(vulnerabilities, null, 2);

    if (this.options.outputFile) {
      core.writeTextFile(this.options.outputFile, report);
      this.console.log("Vulnerability tree exported to " + this.options.outputFile);
    }

    if (this.options.outputFileUu) {
      core.writeTextFile(this.options.outputFileUu, new UuStringReport().getUuString(vulnerabilities));
      this.console.log("Vulnerabilities for UU exported to " + this.options.outputFileUu);
    }

    if (this.options.teamcity) {
      Object.values(vulnerabilities).forEach((v) => this.reportToTeamcity(v));
    } else {
      this.console.log(report);
    }
  }

  private detectParser(): IParser {
    const content = core.readTextFile(this.options.sourceReport);
    if (content.includes(":ossIndexAudit")) {
      return new SonatypeParser(console);
    }
    return new OwaspParser(console);
  }

  private reportToTeamcity(occ: IVulnerableOccurrence) {
    const vul = occ.vulnerability;
    const stepTcName = this.teamCityEscape(occ.key) + ": " + this.teamCityEscape(vul.title);
    this.console.log(`##teamcity[testStarted name='${stepTcName}']`);
    this.console.log(`##teamcity[testFailed name='${stepTcName}' message='${this.teamCityEscape(vul.title)}']`);
    if (vul.cve) {
      this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cve' value='${this.teamCityEscape(vul.cve)}']`);
    }
    if (vul.cwe) {
      this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cwe' value='${this.teamCityEscape(vul.cwe)}']`);
    }
    this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='importance' value='${this.teamCityEscape(vul.importance)}']`);
    this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='url' type='link' value='${this.teamCityEscape(vul.url)}']`);

    if (occ.usedBy.length) {
      occ.usedBy.forEach((libraries, i) =>
        this.console.log(`##teamcity[testMetadata testName='${stepTcName}' name='usedBy-${i}' value='${this.teamCityEscape(libraries.join(", "))}']`)
      );
    }
    this.console.log(`##teamcity[testFinished name='${stepTcName}']`);
  }

  private teamCityEscape(text: string): string {
    return text.replace(/\|/g, "||").replace(/'/g, "|'").replace(/\r/g, "|r").replace(/\n/g, "|n").replace(/\]/g, "|]").replace(/\[/g, "|[");
  }
}
