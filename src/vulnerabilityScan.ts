import core from "./core";
import jsonPath from "jsonpath";

export class VulnerabilityScan {
    constructor(private options: ICommandOptions) {}
    private isUuDependency = (name: string)=> {
        return name.startsWith("pkg:maven/uu.appg01/uu_appg01");
    }

    public async run() {
        const content = core.readTextFile(this.options.sourceReport);
        const packageIdList = this.options.dependencyCheck ? this.getDependencyPackageIdList() : [];
        const json = JSON.parse(content);
        const compact = this.getVulnerabilities(json, packageIdList);
        const report = JSON.stringify(compact, null, 2);
        if (this.options.outputFile) {
            core.writeTextFile(this.options.outputFile, report);
            console.log("Vulnerability tree exported to " + this.options.outputFile);
        }

        if (this.options.teamcity) {
            compact.forEach((c) => this.reportToTeamcity(c));
        } else {
            console.log(report);
        }
    }

    private getDependencyPackageIdList() {
        const fileContent = core.readTextFile(this.options.dependencyCheck);
        const json = JSON.parse(fileContent);
        const packageIdList = jsonPath.query(json, "$..dependencies..packages[*].id");
        packageIdList.sort();
        return [...new Set(packageIdList)];
    }

    private reportToTeamcity(vul: IVulnerability) {
        const stepTcName = this.teamCityEscape(vul.displayName);
        console.log(`##teamcity[testStarted name='${stepTcName}']`);
        console.log(`##teamcity[testFailed name='${stepTcName}' message='${this.teamCityEscape(vul.description)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='_title' value='${this.teamCityEscape(vul.title)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cvssScore' type='number' value='${vul.cvssScore}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='cve' value='${this.teamCityEscape(vul.cve)}']`);
        console.log(`##teamcity[testMetadata testName='${stepTcName}' name='id' value='${this.teamCityEscape(vul.id)}']`);
        if (vul.reference) {
            console.log(`##teamcity[testMetadata testName='${stepTcName}' name='reference' type='link' value='${this.teamCityEscape(vul.reference)}']`);
        }
        if (vul.externalReferences && vul.externalReferences) {
            vul.externalReferences.forEach((r, i) =>
                console.log(`##teamcity[testMetadata testName='${stepTcName}' name='externalReferences-${i}' type='link' value='${this.teamCityEscape(r)}']`)
            );
        }
        if (vul.usedBy?.length) {
            vul.usedBy.forEach((r, i) => console.log(`##teamcity[testMetadata testName='${stepTcName}' name='usedBy-${i}' value='${this.teamCityEscape(r)}']`));
        }
        console.log(`##teamcity[testFinished name='${stepTcName}']`);
    }

    private teamCityEscape(text: string): string {
        return text.replace(/\|/g, "||").replace(/'/g, "|'").replace(/\r/g, "|r").replace(/\n/g, "|n").replace(/\]/g, "|]").replace(/\[/g, "|[");
    }

    private getVulnerabilities(json: INodeList, dependencyCheckList: any[]) {
        const vulnearbilities: { [id: string]: IVulnerability } = {};
        let counter = 0;
        Object.entries(json)
            .filter(([name, n]) => (n.vulnerabilities && n.vulnerabilities.length > 1) || dependencyCheckList.includes(name))
            .forEach(([name, n]) => {
                // Virtual vulnerability for dependency check
                if (n.vulnerabilities === null) {
                    n.vulnerabilities = [
                        {
                            id: `dependecy-check-${counter}`,
                            displayName: `Dependency check of ${name}`,
                            title: "Dependency check",
                            description: "",
                            cve: "99",
                            cvssScore: "99",
                            reference: null,
                            externalReferences: [],
                            usedBy: [],
                        },
                    ];
                    counter++;
                }
                n.vulnerabilities.forEach((v) => {
                    vulnearbilities[v.id] = v;
                    vulnearbilities[v.id].usedBy = vulnearbilities[v.id].usedBy || [];
                    const news = this.addSelfAndParents(new Set<string>(), name, json);
                    if (news && news.size) {
                        const asSet = new Set<string>(vulnearbilities[v.id].usedBy);
                        news.forEach((n) => asSet.add(n));
                        vulnearbilities[v.id].usedBy = [...asSet];
                    }
                });
            });
        const vulArray = Object.values(vulnearbilities).filter((v) => v.usedBy.length);
        vulArray.forEach((v) => {
            v.usedBy = [...v.usedBy] as any;
        });
        return vulArray;
    }

    private addSelfAndParents(nodes: Set<string>, name: string, json: INodeList): Set<string> {
        if (!name || name == "ROOT") {
            if (this.options.uu ==="only") {
                for(const node of [...nodes]){
                        if (this.isUuDependency(node)) {
                            return nodes;
                        }

                }
                return null;
            }else return nodes;
        }
        if (this.options.uu ==="except") {

                if (this.isUuDependency(name)) {
                    return null;

            }
        }
        nodes.add(name);
        const parent = json[name];
        if (parent) {
            return this.addSelfAndParents(nodes, parent.from, json);
        }
    }
}

type INodeList = { [pack: string]: INode };

interface INode {
    from: string;
    vulnerabilities: IVulnerability[];
}

interface IVulnerability {
    id: string;
    displayName: string;
    title: string;
    description: string;
    cve: string;
    cvssScore: string;
    reference: string;
    externalReferences: string[];
    usedBy: string[];
}

export interface ICommandOptions {
    sourceReport: string;
    outputFile: string;
    dependencyCheck: string;
    teamcity: boolean;
    uu: string;
}
