import core from "./core";
import path from "path";

export class VulnerabilityScan {
    private whitelist: string[] = [
        "pkg:maven/uu.appg01/uu_appg01_oidc-client@",
        "pkg:maven/uu.appg01/uu_appg01_messagebroker@",
        "pkg:maven/uu.appg01/uu_appg01_server@",
    ];

    constructor(private reportPath: string, private outputFile: string, private isTeamcity: boolean) {}

    public async run() {
        const content = core.readTextFile(this.reportPath);
        const json = JSON.parse(content);
        const compact = this.getVulnerabilities(json);
        const parsed = path.parse(this.reportPath);
        const destFile = parsed.dir + path.sep + parsed.name + "_tree.json";
        const report = JSON.stringify(compact, null, 2);
        if (this.outputFile) {
            core.writeTextFile(destFile, report);
            console.log("Vulnerability tree exported to " + destFile);
        } else {
            console.log(report);
        }
    }

    private getVulnerabilities(json: INodeList) {
        const vulnearbilites: { [id: string]: IVulnerability } = {};
        Object.entries(json)
            .filter(([_name, n]) => n.vulnerabilities && n.vulnerabilities.length > 1)
            .forEach(([name, n]) =>
                n.vulnerabilities.forEach((v) => {
                    vulnearbilites[v.id] = v;
                    vulnearbilites[v.id].usedBy = vulnearbilites[v.id].usedBy || new Set<string>();
                    const news = this.addSelfAndParents(new Set<string>(), name, json);
                    if (news && news.size) {
                        news.forEach((n) => vulnearbilites[v.id].usedBy.add(n));
                    }
                })
            );
        const vulArray = Object.values(vulnearbilites).filter((v) => v.usedBy.size);
        vulArray.forEach((v) => {
            v.usedBy = [...v.usedBy] as any;
        });
        return vulArray;
    }

    private addSelfAndParents(nodes: Set<string>, name: string, json: INodeList): Set<string> {
        if (!name || name == "ROOT") {
            return nodes;
        }
        for (const pattern of this.whitelist) {
            if (name.indexOf(pattern) > -1) {
                return null;
            }
        }
        nodes.add(name);
        const parent = json[name];
        if (parent) {
            return this.addSelfAndParents(nodes, parent.from, json);
        }
    }
}

type INodeList = { [pack: string]: INode };

interface INode {
    from: string;
    vulnerabilities: IVulnerability[];
}

interface IVulnerability {
    id: string;
    usedBy: Set<string>;
}
