import core from "./core";
import { ICommandOptions, IConsole, INode, IParser, IVulnerability } from "./interfaces";

export class SonatypeParser implements IParser {
  private readonly libraryIdentifier = "+---";

  constructor(private console: IConsole) {}

  public parse(options: ICommandOptions): INode[] {
    const content = core.readTextFile(options.sourceReport);
    const lines = this.getTreeLines(content);
    const tree = this.getTree(lines);
    // core.writeTextFile("../testingOutput.txt", this.testingPrint(tree));
    return tree;
  }

  /* istanbul ignore next */
  testingPrint(nodes: INode[]): string {
    let str: string = "";
    for (const node of nodes) {
      str += `${"|    ".repeat(node.level - 1)}${this.libraryIdentifier} ${node.library}:${node.version}: ${
        node.vulnerabilities.length
      } vulnerabilities detected\r\n`;
      for (const vul of node.vulnerabilities) {
        if (vul.cve) {
          str += `${"|    ".repeat(Math.max(node.level - 1, 0))}     \x1b[31m[${vul.cve}] ${vul.cwe}: ${vul.title} (${vul.importance}): ${vul.url}\x1b[0m\r\n`;
        } else {
          str += `${"|    ".repeat(Math.max(node.level - 1, 0))}     \x1b[31m${vul.title} (${vul.importance}): ${vul.url}\x1b[0m\r\n`;
        }
      }
      if (node.childNodes.length > 0) {
        str += this.testingPrint(node.childNodes);
      }
    }
    return str;
  }

  private getTree(lines: string[]): INode[] {
    const root: INode = {
      level: 0,
      library: "ROOT",
      childNodes: [],
      version: "",
      vulnerabilities: [],
    };
    this.createSubNode(root, root, lines);
    return root.childNodes;
  }

  private createSubNode(parentNode: INode, prevNode: INode, lines: string[]): INode | undefined {
    let line = lines.shift();
    while (line) {
      const idIndex = line.indexOf(this.libraryIdentifier);
      if (idIndex > -1) {
        const beforeIdentifier = line.substring(0, idIndex);
        const level = beforeIdentifier.split("|").length;
        const match = line
          .substring(idIndex + this.libraryIdentifier.length)
          .trim()
          .match(/^(.*):([^:]+):\s*([^:]+)$/);
        let node: INode = {
          level,
          library: match ? match[1] : line,
          version: match ? match[2].replace(" (*)", "") : "",
          childNodes: [],
          vulnerabilities: [],
        };

        if (prevNode.level === level) {
          parentNode.childNodes.push(node);
        } else if (level > prevNode.level) {
          prevNode.childNodes.push(node);
          const nextNode = this.createSubNode(prevNode, node, lines);
          if (nextNode?.level === parentNode.level + 1) {
            parentNode.childNodes.push(nextNode);
            node = nextNode;
          } else {
            return nextNode;
          }
        } else {
          return node;
        }
        prevNode = node;
      } else {
        const vul = this.parseVulnerability(line);
        if (vul) {
          prevNode.vulnerabilities.push(vul);
        }
      }
      line = lines.shift();
    }
    return undefined;
  }

  private parseVulnerability(line: string): IVulnerability | undefined {
    // |    |         \u001b[31m[CVE-2020-36518] CWE-787: Out-of-bounds Write (7.5/10, High): https://ossindex.sonatype.org/vulnerability/CVE-2020-36518?...\u001b[0m
    line = line.replace(/^(\|\s+)*/g, "").trim();
    line = line.replace(/\u001b.*?m/g, "");
    let match = line.match(/^\[(.*)\] (.*): (.*) \((.*)\): (.*)$/);
    if (match) {
      return {
        cve: match[1],
        cwe: match[2],
        title: match[3],
        importance: match[4],
        url: match[5],
      };
    }
    // 1 vulnerability found (7.5/10, High): https://ossindex.sonatype.org/vulnerability/sonatype-2021-4682
    match = line.match(/^(.*) \((.*)\): (.*)$/);
    if (match) {
      return {
        title: match[1],
        importance: match[2],
        url: match[3],
      };
    }
    this.console.log(line);

    this.console.error(`Cannot parse: ${line}`);
  }

  /**
   * Returns only lines that contains dependencies and vulnerabilites.
   * @param content
   */
  private getTreeLines(content: string): string[] {
    let lines = content.split(/\r?\n/);
    const range = { fromLine: -1, toLine: 0 };
    for (let lineNumber = 1; lineNumber <= lines.length; lineNumber++) {
      const line = lines[lineNumber - 1];
      if (line.match(/^[+|]/)) {
        if (range.fromLine === -1) {
          range.fromLine = lineNumber;
        }
        range.toLine = lineNumber;
      }
      if (!line.includes(this.libraryIdentifier)) {
      }
    }
    return lines.slice(range.fromLine - 1, range.toLine);
  }
}
