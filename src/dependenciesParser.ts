import core from "./core";
import { IConsole, INode } from "./interfaces";

export class DependenciesParser {
  constructor(private console: IConsole) {}

  public parse(file: string): INode[] {
    const content = core.readTextFile(file);
    const confs = this.getConfigurationSegments(content);
    const allNodes: INode[] = [];
    for (const conf of confs) {
      const root = this.getTree(conf);
      if (root.library === "checkstyle") {
        continue;
      }
      for (const node of root.childNodes) {
        allNodes.push(node);
      }
    }
    // core.writeTextFile("test.json", JSON.stringify(treeList, null, 2));
    return allNodes;
  }

  /**
   * Returns only lines that contains dependencies and vulnerabilites.
   * @param content
   */
  private getConfigurationSegments(content: string): IConfigurationLines[] {
    let lines = content.split(/\r?\n/);
    // Remove lock file statements
    lines = lines.filter((l) => !l.match(/\{strictly.* \(c\)$/));
    const configurations: IConfigurationLines[] = [];
    let current: IConfigurationLines = {
      configurationName: "",
      lines: [],
    };
    let fromLine = 0;
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      const match = line.match(/^([a-z]+)(\s-\s.*)?$/i);
      if (!current.configurationName && match) {
        current.configurationName = match[1];
        fromLine = lineIndex + 1;
      }
      if (line.trim() === "" && fromLine) {
        current.lines = lines.slice(fromLine, lineIndex);
        if (current.lines.length > 0 && current.lines[0].trim() != "No dependencies") {
          configurations.push(current);
        }
        current = { configurationName: "", lines: [] };
        fromLine = 0;
      }
    }
    return configurations;
  }

  private getTree(segment: IConfigurationLines): INode {
    const root: INode = {
      level: 0,
      library: segment.configurationName,
      childNodes: [],
      version: "",
      vulnerabilities: [],
    };
    this.createSubNode(root, root, segment.lines);
    return root;
  }

  private createSubNode(parentNode: INode, prevNode: INode, lines: string[]): INode | undefined {
    let line = lines.shift();
    while (line) {
      const idIndex = line.indexOf("---");
      const libraryText = line.substring(idIndex + 4).trim();
      // 0 => 1, 6 => 2, 11 => 3, 16 => 4
      const level = idIndex == 0 ? 1 : Math.floor((idIndex + 4) / 5);
      const match = libraryText.trim().match(/^(.+?:.+?):(.+?)$/);
      let node: INode = {
        level,
        library: match ? match[1] : libraryText,
        version: match ? this.parseVersion(match[2]) : "",
        childNodes: [],
        vulnerabilities: [],
      };

      if (prevNode.level === level) {
        parentNode.childNodes.push(node);
      } else if (level > prevNode.level) {
        prevNode.childNodes.push(node);
        const nextNode = this.createSubNode(prevNode, node, lines);
        if (nextNode?.level === parentNode.level + 1) {
          parentNode.childNodes.push(nextNode);
          node = nextNode;
        } else {
          return nextNode;
        }
      } else {
        return node;
      }
      prevNode = node;

      line = lines.shift();
    }
    return undefined;
  }

  private parseVersion(versionString: string): string {
    versionString = versionString.replace(/ \(.\)$/, "");
    const match = versionString.match(/^(.+ -> )?(\S+)$/);
    if (match) {
      return match[2];
    }
    const matchProject = versionString.match(/^(.+) -> project .*$/);
    if (matchProject) {
      return matchProject[1];
    }
    this.console.error(`Version '${versionString}' is not in pattern '2.14.1' or '2.14.1 -> 2.13.5 (c)'`);
    return versionString;
  }
}

interface IConfigurationLines {
  configurationName: string;
  lines: string[];
}
